#include "NXCDefs.h"
#include "HTSMUX-driver.h"

#define TurnLeftTime 2200
#define TurnRightTime 1500

enum direction {
  FAST_LEFT,
  LEFT,
  FAST_RIGHT,
  RIGHT
};

int sen1 = false;
int sen2 = false;
int sen3 = false;
int sen4 = false;
int sen5 = false;
int rotaOLD = 0;
int rotaNEW = 0;
int tickOLD = 0;
int tickNEW = 0;
int OldCheck = false;
int lastFwd = false;
int switchTimeOut = 0;
int blockDist = 0;
string direct = "RIGHT";

void init () {

  SetSensor(S4, SENSOR_LOWSPEED);

  // Tell the SMUX to start scanning its ports.
  // this takes 500ms
  if (!HTSMUXscanPorts(S4)) {
    // Scan failed, handle the error
    TextOut(0, LCD_LINE1, "Scan failed!");
    Wait(1000);
    StopAllTasks();
  }


  SetSensorType(IN_1, SENSOR_TYPE_LIGHT_ACTIVE);
  SetSensorType(IN_2, SENSOR_TYPE_LOWSPEED);
  SetSensorType(IN_3, SENSOR_TYPE_LOWSPEED);
  if (!smuxSetSensorLegoLight(msensor_S4_1, true)) {
    TextOut(0, LCD_LINE1, "smux sens 1 failed!");
    Wait(1000);
    StopAllTasks();
  }
  if (!smuxSetSensorLegoLight(msensor_S4_2, true)) {
    TextOut(0, LCD_LINE1, "smux sens 2 failed!");
    Wait(1000);
    StopAllTasks();
  }
  if (!smuxSetSensorLegoLight(msensor_S4_3, true)) {
    TextOut(0, LCD_LINE1, "smux sens 3 failed!");
    Wait(1000);
    StopAllTasks();
  }
  if (!smuxSetSensorLegoLight(msensor_S4_4, true)) {
    TextOut(0, LCD_LINE1, "smux sens 4 failed!");
    Wait(1000);
    StopAllTasks();
  }
  
  TextOut(0, LCD_LINE1, "ready...");
  until(ButtonPressed(BTNCENTER,false));
  if (ButtonPressed(BTNLEFT,false)) {
    direct = "LEFT";
    ClearLine(LCD_LINE6);
    TextOut(0,LCD_LINE6,"left");
  }
  else if (ButtonPressed(BTNRIGHT,false)) {
    direct = "RIGHT";
    ClearLine(LCD_LINE6);
    TextOut(0,LCD_LINE6,"left");
  }
  ClearScreen();

}

int sec (float second) {
  int ms = second * 1000;
  return ms;
}

int sens (int num) {
  int ret;
  switch (num) {
    case -1:
      ret = SensorUS(IN_3);
      break;
    case 0:
      ret = SensorUS(IN_2);
      break;
    case 1:
      ret = smuxSensorLegoLightNorm(msensor_S4_1);
      break;
    case 2:
      ret = smuxSensorLegoLightNorm(msensor_S4_2);
      break;
    case 3:
      ret = Sensor(IN_1);
      break;
    case 4:
      ret = smuxSensorLegoLightNorm(msensor_S4_4);
      break;
    case 5:
      ret = smuxSensorLegoLightNorm(msensor_S4_3);
      break;
    default:
      ClearScreen();
      TextOut(0, LCD_LINE1, "Error:");
      TextOut(0, LCD_LINE2, "num can only be -1 to 5");
      Wait(1000);
  }
  return ret;
}

void updateActive () {
  if (sens(1) < 50) {
    sen1 = true;
  }
  else {
    sen1 = false;
  }

  if (sens(2) < 50) {
    sen2 = true;
  }
  else {
    sen2 = false;
  }
  if (sens(3) < 700) {
    sen3 = true;
  }
  else {
    sen3 = false;
  }

  if (sens(4) < 50) {
    sen4 = true;
  }
  else {
    sen4 = false;
  }

  if (sens(5) < 50) {
    sen5 = true;
  }
  else {
    sen5 = false;
  }
}




void Move (int motorL, int motorR) {
  if (motorL == motorR && motorL != 0) {
    OnFwdReg(OUT_AC,motorL,OUT_REGMODE_IDLE);
  }
  else {
    if (motorL == 0) {
      Off(OUT_A);
    }
    else if (motorL >= 0) {
      OnFwdReg(OUT_A,motorL,OUT_REGMODE_IDLE);
    }
    else {
      OnRevReg(OUT_A,0-motorL,OUT_REGMODE_IDLE);
    }

    if (motorR == 0) {
      Off(OUT_C);
    }
    else if (motorR >= 0) {
      OnFwdReg(OUT_C,motorR,OUT_REGMODE_IDLE);
    }
    else {
      OnRevReg(OUT_C,0-motorR,OUT_REGMODE_IDLE);
    }
  }
}

void MoveNor (int motorL, int motorR) {
  if (motorL == motorR && motorL != 0) {
    OnFwd(OUT_AC,motorL);
  }
  else {
    if (motorL == 0) {
      Off(OUT_A);
    }
    else if (motorL >= 0) {
      OnFwd(OUT_A,motorL);
    }
    else {
      OnRev(OUT_A,0-motorL);
    }

    if (motorR == 0) {
      Off(OUT_C);
    }
    else if (motorR >= 0) {
      OnFwd(OUT_C,motorR);
    }
    else {
      OnRev(OUT_C,0-motorR);
    }
  }
}

void MoveMotor (int motor,int motorDeg) {
  if (motorDeg == 0) {
    Off(motor);
  }
  else if (motorDeg >= 0) {
    OnFwdReg(motor,motorDeg,OUT_REGMODE_IDLE);
  }
  else {
    OnRevReg(motor,0-motorDeg,OUT_REGMODE_IDLE);
  }
}

void WaitForLine (direction d) {
  if (d == FAST_LEFT || d == FAST_RIGHT) {
    ClearLine(LCD_LINE8);
    TextOut(0, LCD_LINE8, "fast!");
    until(sens(3) >= 600 );
  }
  else {
    ClearLine(LCD_LINE8);
    TextOut(0, LCD_LINE8, "normal!");
  }
  long OldTime = CurrentTick();
  while (true) {
    if (sens(3) < 600)  {
      break;
    }
    else if (CurrentTick() > OldTime + 1700) {
      switch (d) {
        case FAST_LEFT:
          ClearLine(LCD_LINE8);
          TextOut(0, LCD_LINE8, "fast left!");
          Move(-75,75);
          Wait(1500);

          break;

        case LEFT:
          ClearLine(LCD_LINE8);
          TextOut(0, LCD_LINE8, "left!");
          Move(-75,75);
          Wait(1500);

          break;
        case FAST_RIGHT:
          TextOut(0, LCD_LINE8, "fast right!");
          Move(75,-75);
          Wait(1500);
          ClearLine(LCD_LINE8);
          break;
        case RIGHT:
          TextOut(0, LCD_LINE8, "right!");
          Move(75,-75);
          Wait(1500);
          ClearLine(LCD_LINE8);
          break;
      }
      break;
    }
  }
}

void RotaForDeg(int deg) {
  int ThisRotaOLD = MotorRotationCount(OUT_C);
  Move(-75,75);
  until(MotorRotationCount(OUT_C) - ThisRotaOLD > deg * (1400/180));
}

void Ramp () {
  int RampStartTick = CurrentTick();
  while (true) {
    updateActive();
    ClearLine(LCD_LINE2);
    if (sen2) {
      TextOut(0, LCD_LINE2, "left");
      Move(80,100);
    }
    else if (sen4) {
      TextOut(0, LCD_LINE2, "right");
      Move(100,60);
    }
    else {
      TextOut(0, LCD_LINE2, "forward");
      OnFwdReg(OUT_AC,75,OUT_REGMODE_IDLE);
      rotaOLD = rotaNEW;
      rotaNEW = MotorRotationCount(OUT_A);
      tickOLD = tickNEW;
      tickNEW = CurrentTick();

      if (sens(0) < 11) {
        ClearScreen();
        TextOut(1, LCD_LINE1, "Normal");
        Move(-75,-75);
        Wait(600);
        if (CurrentTick() > RampStartTick + 4000) {
          switchTimeOut = CurrentTick();
        }
        break;
      }
      else if (!(rotaNEW - rotaOLD < 4 *( tickNEW - tickOLD ) / 10) )  {
        ClearScreen();
        TextOut(1, LCD_LINE1, "Normal");
        if (CurrentTick() > RampStartTick + 4000) {
          switchTimeOut = CurrentTick();
        }
        break;
      }

    }
  }
}
void FolowLine () {
  OnFwd(OUT_B,10);
  while (true) {
    updateActive();

    if (sens(0) < 10) {  // && CurrentTick() > switchTimeOut + 500
      lastFwd = false;
      OldCheck = false;
      if (sens(-1) < 25) {
        // go right

        Move(-75,-75);
        Wait(200);

        Move(75,-75);
        Wait(1200);

        Move(75,75);
        Wait(700);

        Move(20,100);
        Wait(1000);

        //Move(0,0);
        //until(false);

        until(sens(3) < 600);
        Move(75,75);
        Wait(200);
        Move(75,-75);
        until(sens(3) < 600);
        switchTimeOut = CurrentTick();
      }
      else {
        // go left

        Move(-75,-75);
        Wait(200);

        Move(-75,75);
        Wait(1200);

        Move(75,75);
        Wait(700);

        Move(100,20);
        Wait(1000);

        //Move(0,0);
        //until(false);

        until(sens(3) < 600);
        Move(75,75);
        Wait(200);
        Move(-75,75);
        until(sens(3) < 600);
        switchTimeOut = CurrentTick();

      }
    }
    else if (sen1 && sen5) {
      if (direct == "RIGHT") {
        // right
        ClearLine(LCD_LINE5);
        TextOut(0,LCD_LINE5,"right!");
        lastFwd = false;
        Move(75,75);
        Wait(200);
        Move(75,-75);
        WaitForLine(LEFT);
      }
      else {
        ClearLine(LCD_LINE5);
        TextOut(0,LCD_LINE5,"left!");
        lastFwd = false;
        Move(75,75);
        Wait(200);
        Move(-75,75);
        WaitForLine(RIGHT);
      }

    }
    else if (sen1) {
      /*lastFwd = false;
      Move(75,75);
      Wait(200);
      Move(-75,75);
      WaitForLine(FAST_RIGHT);*/

      if ( direct == "LEFT" ) {
        lastFwd = false;
        Move(75,75);
        Wait(200);
        Move(-100,75);
        WaitForLine(FAST_RIGHT);
      }
      else {
        lastFwd = false;
        Move(-75,75);
        WaitForLine(RIGHT);
      }

    }
    else if (sen5) {
      /*lastFwd = false;
      Move(75,75);
      Wait(200);
      Move(75,-75);
      WaitForLine(FAST_LEFT);*/
      if ( direct == "RIGHT" ) {
        lastFwd = false;
        Move(75,75);
        Wait(200);
        Move(75,-100);
        WaitForLine(FAST_LEFT);
      }
      else {
        TextOut(0,LCD_LINE5,"else!");
        lastFwd = false;
        Move(75,-75);
        WaitForLine(LEFT);
      }

    }
    else if (sen2) {
      lastFwd = false;
      Move(-75,75);
      WaitForLine(LEFT);
    }
    else if (sen4) {
      lastFwd = false;
      Move(75,-75);
      WaitForLine(RIGHT);
    }
    else if (sens(3) > 760) {
      Move(0,0);
      break;
    }
    else {
      Move(75,75);
      
      /*rotaOLD = rotaNEW;
      rotaNEW = MotorRotationCount(OUT_A);
      tickOLD = tickNEW;
      tickNEW = CurrentTick();

      ClearScreen();
      if (rotaNEW - rotaOLD < 4 *( tickNEW - tickOLD ) / 10 )  {
        if (CurrentTick() < switchTimeOut + 1000) { }
        else if (OldCheck == true && lastFwd == true) {
          TextOut(1, LCD_LINE1, "Ramp");
          OldCheck = false;
          Ramp();
        }
        else if (OldCheck == true) {
          OldCheck = false;
          TextOut(1, LCD_LINE1, "Normal");
        }
        else {
          OldCheck = true;
          TextOut(1, LCD_LINE1, "Normal");
        }

      }
      else {
        TextOut(1, LCD_LINE1, "Normal");
        OldCheck = false;
      }
      lastFwd = true;*/
    }
  }
}

void FindBlock () {
  // find block
  Move(40,40);
  Wait(1500);
  int dis = 70;
  if (sens(-1) < 30) {
    MoveNor(100,0);
    Wait(TurnRightTime);
    Move(40,40);
    dis = 55;
  }
  while (true) {
    ClearScreen();
    NumOut(0, LCD_LINE1, dis);

    if (sens(-1) < dis) {
      blockDist = sens(-1);
      MoveNor(0,0);
      Wait(500);
      if (sens(-1) < dis) {
        NumOut(0, LCD_LINE1, sens(-1) );
        break;
      }
    }
    else if (sens(0) < 25) {
      dis = 55;
      MoveNor(0,100);
      Wait(TurnLeftTime);
      Move(40,40);
    }
    else {
      Move(40,40);
    }
  }

  MoveNor(-40,-40);
  Wait(1400);
  MoveNor(0,100);
  Wait(1600);
  until(sens(0) <= dis);
  NumOut(0, LCD_LINE1, sens(0));

  //Move(0,-75);
  //Wait(200);

  //until(sens(0) < 30);
  MoveNor(40,40);
  //Wait(1700);
  Wait(blockDist*50);
  

  MoveNor(-75,75);
  long OldTime = CurrentTick();
  while (true) {
    if (sens(0) < 27)  {
      break;
    }
    else if (CurrentTick() > OldTime + 1800) {
      MoveNor(75,-75);
      until(sens(0) < 27);
      break;
    }
  }
  
  // Block is found
  ClearScreen();
  TextOut(0, LCD_LINE1, "Block is found!");

  // ---- rotating ---- //
  //RotaForDeg(160);
  Move(75,-75);
  Wait(4000);
  TextOut(0,LCD_LINE4,"test");
  MoveNor(-40,-40);
  Wait(200);
  
  MoveMotor(OUT_B,40);
  Wait(1000);
  //OnFwd(OUT_B,10);
  Off(OUT_B);

  // Block is get
  rotaNEW = MotorRotationCount(OUT_C);
  rotaOLD = rotaNEW - 100;
  int allowTurnTime = 0;
  while (true) {
    Move(50,50);
    rotaOLD = rotaNEW;
    rotaNEW = MotorRotationCount(OUT_C);
    if (sens(3) < 500) {
      Move(0,0);
      Wait(500);
      if (sens(3) < 500) {
        break;
      }
    }
    else if ( (rotaNEW - rotaOLD == 0 || sens(3) > 800) && allowTurnTime == 0) {
      Move(-75,-75);
      Wait(600);
      Move(0,100);
      Wait(TurnLeftTime);
      rotaNEW = MotorRotationCount(OUT_C);
      rotaOLD = rotaNEW - 100;
      ClearLine(LCD_LINE1);
      ClearLine(LCD_LINE2);

      NumOut(0,LCD_LINE1,rotaNEW - rotaOLD);
      NumOut(0,LCD_LINE2,MotorRotationCount(OUT_C));
      allowTurnTime = 20;
    }
    else if (allowTurnTime != 0) {
      allowTurnTime = allowTurnTime - 1;
    }
    Wait(50);
  }


  // Black is found
  Move(-75,-75);
  Wait(1000);

  // ---- rotating ---- //
  //RotaForDeg(160);
  Move(75,-75);
  Wait(4000);
  Move(0,0);

  MoveMotor(OUT_B,-100);
  Wait(1000);
  MoveMotor(OUT_B,0);

  Move(-75,-75);
  Wait(1000);

  Move(40,40);
  Wait(500);

  Move(0,0);
  
}

task main () {
  init();
  FolowLine();
  FindBlock();
}
