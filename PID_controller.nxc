#include "NXCDefs.h"
#include "HTSMUX-driver.h"

#define HalfChageVal 300
#define FullChageVal 800
typedef struct {
  int light;
  int dark;
} CaliSens;
// 13s
// Define values

mutex motorMutex;

CaliSens cali[7];
//  Working on: 5/1/2015
float Kp = 0.416666667;//(0-20)/(-48-0);
float Ki = 0.025;
float Kd = 0.05;//0.005;
float offset = 1950;
float Tp = 80;
float integral = 0;
float lastError = 0;
float derivative = 0;
int sideOfLine = 1;
int time = 200;
int lastSen = 0;
/*
float Kp = 0.4;
float Ki = 0;//0.05;
float Kd = 0.1;//0.2;
float offset;
float Tp = 75;
float integral = 0;
float lastError = 0;
float derivative = 0;
*/float error;
float turn;

long minBlack = 30;

void init () {

  SetSensorType(IN_1, SENSOR_TYPE_LIGHT_ACTIVE);
  SetSensorType(IN_2, SENSOR_TYPE_LIGHT_ACTIVE);
  SetSensorType(IN_3, SENSOR_TYPE_LIGHT_ACTIVE);
  SetSensor(S4, SENSOR_LOWSPEED);

  // Tell the SMUX to start scanning its ports.
  // this takes 500ms
  if (!HTSMUXscanPorts(S4)) {
    // Scan failed, handle the error
    TextOut(0, LCD_LINE1, "Scan failed!");
    Wait(1000);
    StopAllTasks();
  }
  
  if (!smuxSetSensorLegoLight(msensor_S4_1, true)) {
    TextOut(0, LCD_LINE1, "smux sens 1 failed!");
    Wait(1000);
    StopAllTasks();
  }
  if (!smuxSetSensorLegoLight(msensor_S4_2, true)) {
    TextOut(0, LCD_LINE1, "smux sens 2 failed!");
    Wait(1000);
    StopAllTasks();
  }
  if (!smuxSetSensorLegoLight(msensor_S4_3, true)) {
    TextOut(0, LCD_LINE1, "smux sens 3 failed!");
    Wait(1000);
    StopAllTasks();
  }
  if (!smuxSetSensorLegoLight(msensor_S4_4, true)) {
    TextOut(0, LCD_LINE1, "smux sens 4 failed!");
    Wait(1000);
    StopAllTasks();
  }

}

int port (int pontNum) {
  int ret;
  switch (pontNum) {
    case 1:
      ret = IN_1;
      break;
    case 2:
      ret = IN_1;
      break;
    case 3:
      ret = IN_1;
      break;
    case 4:
      ret = IN_1;
      break;
  }
  return ret;
}

long rawSens (int num) {
  long ret;
  switch (num) {
    case 0:
      ret = smuxSensorLegoLightNorm(msensor_S4_2);
      break;
    case 1:
      ret = smuxSensorLegoLightNorm(msensor_S4_1);
      break;
    case 2:
      ret = Sensor(IN_3)/10;
      break;
    case 3:
      ret = Sensor(IN_2)/10;
      break;
    case 4:
      ret = Sensor(IN_1)/10;
      break;
    case 5:
      ret = smuxSensorLegoLightNorm(msensor_S4_4);
      break;
    case 6:
      ret = smuxSensorLegoLightNorm(msensor_S4_3);
      break;
    default:
      ClearScreen();
      TextOut(0, LCD_LINE1, "Error:");
      TextOut(0, LCD_LINE2, "num can only be 1 to 3");
      Wait(1000);
  }
  ret = 100-ret;
  /*if (num == 5) {
    ret = 100-ret;
  }*/
  return ret;
}

long sens (int num) {
  long ret = rawSens(num);
  ret = (ret - cali[num].light) * (100/(cali[num].dark-cali[num].light));
  if (ret < 0) {
    ret = 0;
  }
  if (ret > 100) {
    ret = 100;
  }
  
  
  /*SetSensorType(port(num), IN_TYPE_LIGHT_ACTIVE);
  ret = rawSens(num) - (ret - rawSens(num));
  
  SetSensorType(port(num), IN_TYPE_LIGHT_INACTIVE);
  ret = rawSens(num);*/

  
  /*if (num == 5) {
    ret = 100-ret;
  }*/
  return ret;
}

int line (int line) {
  int ret;
  switch (line) {
    case 1:
      ret = LCD_LINE1;
      break;
    case 2:
      ret = LCD_LINE2;
      break;
    case 3:
      ret = LCD_LINE3;
      break;
    case 4:
      ret = LCD_LINE4;
      break;
    case 5:
      ret = LCD_LINE5;
      break;
    case 6:
      ret = LCD_LINE6;
      break;
    case 7:
      ret = LCD_LINE7;
      break;
    case 8:
      ret = LCD_LINE8;
      break;
  }
  return ret;
}

void Move (float motorL, float motorR) {
  motorL = -motorL;
  motorR = -motorR;
  if (motorL > 100) {
    //motorL = 100;
    float change = motorL/100;
    motorL = motorL/change;
    motorR = motorR/change;
  }
  else if (motorL < -100) {
    //motorL = -100;
    float change = motorL/-100;
    motorL = motorL/change;
    motorR = motorR/change;
  }
  if (motorR > 100) {
    //motorR = 100;
    float change = motorR/100;
    motorL = motorL/change;
    motorR = motorR/change;
  }
  else if (motorR < -100) {
    //motorR = -100;
    float change = motorR/-100;
    motorL = motorL/change;
    motorR = motorR/change;
  }
  if (motorL == motorR && motorL != 0) {
    if (motorL >= 0) {
      OnFwd(OUT_AC,motorL);
    }
    else {
      OnRev(OUT_AC,0-motorL);
    }
  }
  else {
    if (motorL == 0) {
      Off(OUT_C);
    }
    else if (motorL >= 0) {
      OnFwd(OUT_C,motorL);
    }
    else {
      OnRev(OUT_C,0-motorL);
    }

    if (motorR == 0) {
      Off(OUT_A);
    }
    else if (motorR >= 0) {
      OnFwd(OUT_A,motorR);
    }
    else {
      OnRev(OUT_A,0-motorR);
    }
  }
}

long getCurrent () {
  /*return (
    sens(1)
    + sens(2)*100
    + sens(3)*200
    + sens(4)*300
    + sens(5)*400
  )
    /
  (
    sens(1)
    + sens(2)
    + sens(3)
    + sens(4)
    + sens(5)
  );*/
  return sens(3);
}

void debugNum (int line, int num) {
  ClearLine(line);
  NumOut(0,line,num);
}
void debugAll () {
  /*debugNum(LCD_LINE1,sens(0));
  debugNum(LCD_LINE2,sens(1));
  debugNum(LCD_LINE3,sens(2));
  debugNum(LCD_LINE4,sens(3));
  debugNum(LCD_LINE5,sens(4));
  debugNum(LCD_LINE6,sens(5));
  debugNum(LCD_LINE7,sens(6));
  debugNum(LCD_LINE8,getCurrent());*/

  for (int i = 0; i < 7; i++) {
    ClearLine(line(i+1));
    NumOut(0,line(i+1),sens(i));
      NumOut(25,line(i+1),rawSens(i));
      NumOut(50,line(i+1),cali[i].light);
      NumOut(75,line(i+1),cali[i].dark);
    }
    ClearLine(line(8));
    //NumOut(0,line(8),integral);
    NumOut(25,line(8),getCurrent()-offset);
}


void readCali () {
  CaliSens ret[7];
  string buffer;
  byte file = fopen("cali.txt", "r");
  if (file == NULL) {
    StopAllTasks();
  }
  for (int i=0; i<7; i++) {
    fgets(buffer, 10, file);
    ret[i].light = atol(buffer);

    fgets(buffer, 10, file);
    ret[i].dark = atol(buffer);
  }
  
  fclose(file);
  cali = ret;
  
  /*for (int i=0; i<7; i++) {
    cali[i].light = cali[i].light + 5;
    cali[i].dark = cali[i].dark - 5;
  }*/
}

bool seeSomthing () {
  return (
    sens(2) > 60
    || sens(3) > 80
    || sens(4) > 60
  );
}

task PID () {
  sideOfLine = 1;
  while (true) {
    if (sens(4) > 60 || (time < 1 && lastSen == 1)) {
      if (time == 0) {
        ClearScreen();
        TextOut(0, LCD_LINE1,"Chaning to -1");
        Move(80,0);
        long OldTime = CurrentTick();
        while (true) {
          if (sens(3) > 50)  {
            break;
          }
          else if (CurrentTick() > OldTime + 1000) {
            Move(-80,0);
            until(sens(3) > 50)
          }
        }
        ClearScreen();
        TextOut(0, LCD_LINE1,"following -1");
        sideOfLine = -1;
        lastSen = 0;
        time = 1000;
      }
      else {
        lastSen = 1;
      }
    }
    else if (sens(2) > 60 || (time < 1 && lastSen == -1)) {
      if (time == 0) {
        ClearScreen();
        TextOut(0, LCD_LINE1,"Chaning to 1");
        Move(0,80);
        long OldTime = CurrentTick();
        while (true) {
          if (sens(3) > 50)  {
            break;
          }
          else if (CurrentTick() > OldTime + 1000) {
            Move(0,-80);
            until(sens(3) > 50)
          }
        }
        ClearScreen();
        TextOut(0, LCD_LINE1,"following 1");
        sideOfLine = 1;
        lastSen = 0;
        time = 1000;
      }
      else {
        lastSen = -1;
      }
    }
    else if (time < -800 && lastSen == 0) {
      Move(-80,-80);
      until(seeSomthing());
    }
    else {
      error = getCurrent() - offset;
      integral = integral*(1/3) + error;
      derivative = error - lastError;
      turn = Kp*error + Ki*integral + Kd*derivative;
      if (sideOfLine == 1) {
        Move(Tp+turn,Tp-turn);
      }
      else if (sideOfLine == -1) {
        Move(Tp-turn,Tp+turn);
      }
      if (getCurrent() > 20 ) {
        time = 200;
      }
      lastError = error;
    }
    debugAll();
  }
}

task timer () {
  while (true) {
    if (time > 0) {
      time--;
    }
    Wait(1);
  }
}

task main () {
  init();
  readCali();
  offset = getCurrent(); // 52;
  Precedes(PID, timer);
}
